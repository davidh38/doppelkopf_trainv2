* Doppelkopf Train v2 Rules

This file describes the rules and features of the Doppelkopf Train v2 game.

** General Game Rules
   - [Describe general game rules here]

** Feature-Specific Rules
   - [Describe rules specific to each feature here]

** Card Values
   - [Describe card values here]

** Gameplay
   - See [[./gameplay_specification.org][Gameplay Specification]] for detailed gameplay mechanics and rules

** Data Structures
   - The following immutable data structures will be created:

*** playerdict
   - session: str  # Unique session identifier for the current connection
   - name: str     # Display name of the player
   - type: str     # Player type: "human" for real players, "computer" for AI
   - uuid: str     # Persistent unique identifier for the player across sessions

*** tabledict
   - tablename: str                # Descriptive name of the table shown in the lobby
   - players: List[playerdict]     # List of players currently at the table (up to 4)
   - status: str                   # Table status: "waiting" for players or "playing" a game
   - game: gamedict                # Current game being played at the table

*** announcementdict
   - player_id: str           # UUID of the player who made the announcement
   - type: str                # Type of announcement (e.g., "re", "kontra", "no90", "no60", etc.)
   - trick_number: int        # At which trick the announcement was made (0 means before first trick)
   - timestamp: datetime      # When the announcement was made

*** gamedict
   - rounds: int                   # Total number of rounds to be played in this game
   - round: int                    # Current round number (1-based index)
   - players: List[playerdict]     # Players participating in the game
   - cards: Dict[uuid, List[Card]] # Mapping of player UUIDs to their current hand of cards
   - tricks: List[Tuple]           # History of all tricks played so far in the current round
   - current_player: str           # UUID of the player whose turn it is
   - eligible_cards: List[Card]    # Cards that the current player is allowed to play
   - mode: str                     # Game mode: "solo", "normal", etc.
   - round_phase: str              # Current phase: "variant", "armut" (poverty), "playing"
   - eligible_announcements: Dict  # Announcements each player can make (e.g., "re", "kontra")
   - announcements: List[announcementdict]  # List of all announcements made in the game
   - player_teams: Dict[str, str]  # Mapping of player UUIDs to their team assignment ("re", "kontra", "unknown")
   - round_scores: Dict            # Current scores for each player in this round

   - A table can play one or more games
   - 4 players are needed to play a game
   - A player may be of type human or AI
   - The user gets a random UUID, which is sent with every request to identify the user
   - The server keeps track of all players and tables of the server
   - The frontend will receive a filtered version of the gamedict based on the player's perspective

** Frontend
   - In order to have a more seamless user experience, we will add Socket.IO.
   - There will be 3 main windows:
     - Lobby for game joining and creation
     - The gameplay itself
     - Game summary
   - For identification, JavaScript code will post a UUID with every request.

** Testing
   - For a testing mode, the players can play random but legible cards to a certain point. This can be reproduced.
   - Also, game states should be saved and be able to be started with.
   - For example, a game can be simulated to have run 4 times to the fifth trick. This data structure: user should then be able to connect to the game with the right identification.
   - A game should be replayable by the UI

** Principles
   - Features and design and decisions should be reasons without reasons should have arguments

** Architecture
   - Clean bound boundaries for reuse and flexibility

** Implementation Files
   - src/backend/data_structures.py: Contains the definitions of the core data structures (playerdict, tabledict, gamedict, card_dict)
   - src/backend/table_handler.py: Handles table management operations (creating tables, adding/removing players, etc.)
   - src/backend/game_handler.py: Manages game mechanics and state (card dealing, turn management, card playing logic, etc.)
   - src/backend/game_summary.py: Calculates and generates game summaries (scores, statistics, history recording, etc.)
   - src/backend/game_logger.py: Handles logging of game state after every turn (for debugging, replay, and recovery)

** Logging
   - The game state will be logged after every turn
   - Logging will capture the complete gamedict at each step
   - This will enable:
     - Debugging of game mechanics
     - Replay of games for analysis
     - Recovery in case of errors or disconnections
   - Implementation details:
     - A new file src/backend/game_logger.py will handle logging functionality
     - Logs will be stored in a structured format (JSON)
     - Each game will have its own log file with timestamp and game ID
     - Log files will be stored in a logs/ directory
   - The logging system will be designed to have minimal impact on performance
   - Logs can be used to recreate any point in the game's history

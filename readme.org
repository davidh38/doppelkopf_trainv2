* Project Title: Doppelkopf Train v2

* Project Description
This project is a new game inspired by the previous game, focusing on data-driven design and a functional approach. The `tests` folder is for unit tests.

* Key Features
- Gemini or API flatrates for money saving
- The logic should be easily explainable
- Every game state should be fast attainable in an easy way for example: play a last trick and press new game
- GUI should have no logic at all except for showing, no special routes, everything depends on the game state
- New features will be implemented by pull requests
- Unit tests will test the game like in the last game
- The reuse of the old versions code should be done
- More functional
- Data will be the first citizen and the most important
- Planning before coding
- A rule file will be maintained with every feature
- Game state object will be logged and printed after every move

* Technology Stack
Flask, Python, JavaScript

* Getting Started
[Instructions on how to set up and run the project]

* Contributing
New features will be implemented via pull requests. Please follow the project's coding standards and best practices when contributing.

* License
[Your License Here]

* Specifications
- [[specification.org][This file describes the rules and features of the Doppelkopf Train v2 game.]]
- [[frontend_specification.org][This file details the frontend implementation.]]
- [[gameplay_specification.org][This file details the gameplay mechanics and rules for the Doppelkopf Train v2 game.]]
- [[lobby_and_table_creation_specification.org][This file details the server initialization flow and table creation process.]]

* Doppelkopf Train v2 Rules
This file describes the rules and features of the Doppelkopf Train v2 game.

** General Game Rules
- [Describe general game rules here]

** Feature-Specific Rules
- [Describe rules specific to each feature here]

** Card Values
- [Describe card values here]

** Gameplay
- See [[./gameplay_specification.org][Gameplay Specification]] for detailed gameplay mechanics and rules

** Data Structures
- See [[data_structures.org][Data Structures]] for details on the data structures used in the game.

** Frontend
- In order to have a more seamless user experience, we will add Socket.IO.
- There will be 3 main windows:
  - Lobby for game joining and creation
  - The gameplay itself
  - Game summary
- For identification, JavaScript code will post a UUID with every request.

** Testing
- For a testing mode, the players can play random but legible cards to a certain point. This can be reproduced.
- Also, game states should be saved and be able to be started with.
- For example, a game can be simulated to have run 4 times to the fifth trick. This data structure: user should then be able to connect to the game with the right identification.
- A game should be replayable by the UI

** Principles
- Features and design and decisions should be reasons without reasons should have arguments

** Architecture
- Clean bound boundaries for reuse and flexibility

** Implementation Files
- src/backend/data_structures.py: Contains the definitions of the core data structures (playerdict, tabledict, gamedict, card_dict)
- src/backend/table_handler.py: Handles table management operations (creating tables, adding/removing players, etc.)
- src/backend/game_handler.py: Manages game mechanics and state (card dealing, turn management, card playing logic, etc.)
- src/backend/game_summary.py: Calculates and generates game summaries (scores, statistics, history recording, etc.)
- src/backend/game_logger.py: Handles logging of game state after every turn (for debugging, replay, and recovery)

** Specification Files
- [[./frontend_specification.org][Frontend Specification]]
- [[./gameplay_specification.org][Gameplay Specification]]
- [[./lobby_and_table_creation_specification.org][Lobby and Table Creation Specification]]
- [[./table_creation_specification.org][Table Creation Specification]]

** Logging
- The game state will be logged after every turn
- Logging will capture the complete gamedict at each step
- This will enable:
  - Debugging of game mechanics
  - Replay of games for analysis
  - Recovery in case of errors or disconnections
- Implementation details:
  - A new file src/backend/game_logger.py will handle logging functionality
  - Logs will be stored in a structured format (JSON)
  - Each game will have its own log file with timestamp and game ID
  - Log files will be stored in a logs/ directory
- The logging system will be designed to have minimal impact on performance
- Logs can be used to recreate any point in the game's history
